#!/usr/bin/env python
import os
from datetime import datetime
from typing import List

import code_gen
import postgres_datatypes
from config import Config
from database import Database
from schema import Table, BindVar


def not_none(s: str):
    if s is None:
        return ''
    else:
        return s


class ProtoGen:
    def __init__(self, config: Config, database: Database):
        self.config = config
        self.database = database
        self.path = self.config.get_config()['proto']['path']
        self.java_package = self.config.get_config()['proto']['java_package']
        self.go_package = self.config.get_config()['proto']['go_package']
        self.objc_prefix = self.config.get_config()['proto']['objc_prefix']
        self.version = self.config.get_config()['proto']['version']

    def generate_protos(self):
        print(f'\n------- Generating Protobuffers --------\n')
        for schema in self.database.schemas.values():
            for table in schema.tables.values():
                self.generate(table)

    def generate(self, table: Table):
        proto_path = os.path.sep.join([self.path, table.schema])
        proto_fname = os.path.sep.join([proto_path, table.name + '.proto'])
        print(f'{proto_fname}')
        if not os.path.exists(proto_path):
            os.makedirs(proto_path)
        self.write_proto(proto_fname, table)

    def write_proto(self, proto_fname: str, table: Table):
        with open(proto_fname, 'w') as pfile:
            now = datetime.now()
            header = ("// -*- coding: utf-8 -*-\n"
                      "// ------------------------------------------------------------------------------\n"
                      "// This file is automatically generated from the database schema using py-protodb\n"
                      "// database:     " + self.config.get_config()['database']['database'] + "\n"
                      "// user:         " + self.config.get_config()['database']['user'] + "\n"
                      "// generated on: " + now.strftime("%m/%d/%Y, %H:%M:%S") + "\n"
                      "// ----------------- DO NOT MAKE CHANGES DIRECTLY TO THIS FILE! -----------------\n"
                      "syntax = \"" + self.version + "\";\n\n")
            pfile.write(header)
            pfile.write('package ' + table.schema + ';\n\n')

            # options
            message_name = ''.join(word.title() for word in table.name.split('_'))
            option = ("option cc_enable_arenas = true;\n"
                      "option java_package = \"" + self.java_package + "." + table.schema + "\";\n"
                      "option java_outer_classname = \"" + message_name + "Proto\";\n"
                      "option java_multiple_files = true;\n"
                      "option objc_class_prefix = \"" + self.objc_prefix + "\";\n\n")
            pfile.write(option)

            # other imports
            self.write_imports(pfile, table)

            self.write_message(message_name, pfile, table)

            comment = "//-------------------------- Raw Proto -----------------------------\n"
            pfile.write(comment)

            message_name = 'Raw' + message_name
            self.write_message(message_name, pfile, table, True)

            self.write_custom_proto(pfile, table)
            pfile.close()

    def write_imports(self, pfile, table):
        pfile.write("\n// Other imports\n")
        line_list = []
        for col in table.columns.values():
            line = self.write_special_imports(col.udt_name)
            if line not in line_list:
                line_list.append(line)
        # Now do it for the custom queries
        for qmap in table.mappings.values():
            result_set = qmap.result_set
            if len(result_set) > 0:
                for rset in result_set:
                    line = self.write_special_imports(rset.data_type)
                    if line not in line_list:
                        line_list.append(line)
        [pfile.write(not_none(str(x))) for x in line_list]

    def write_message(self, message_name: str, pfile, table: Table, all_fields: bool = False):
        # message body
        pfile.write("\nmessage " + message_name + " {\n")
        # extensions
        if table.proto_extensions is not None:
            pfile.write("  extensions " + table.proto_extensions + ";\n")
        # enums
        self.write_enums(pfile, table)
        # fields
        if all_fields:
            cnames = list(table.columns.values())
            cnames.sort(key=lambda x: x.ordinal_position)
            col_names = [cn.name for cn in cnames]
        else:
            col_names = table.select_list
        self.write_fields(pfile, table, col_names)
        pfile.write('}\n\n')

    def write_fields(self, pfile, table: Table, col_names: List[str]):
        field_no = 1
        for cname in col_names:
            col = table.columns[cname]
            dtype = col.data_type
            uname = col.udt_name
            ftype = postgres_datatypes.sql_to_proto_datatype(uname)
            if col.valid_values is not None:
                ftype = code_gen.cap_camel_case(cname)

            if dtype == 'ARRAY':
                field_type = 'repeated'
            else:
                if self.version == 'proto2':
                    field_type = 'optional'
                else:
                    field_type = ''
            pfile.write(f'  ' + field_type + ' ' + ftype + ' ' + cname + ' = ' + str(field_no) + ';\n')
            field_no += 1

    @staticmethod
    def write_enums(pfile, table):
        if table.has_valid_values:
            cols = table.columns.values()
            for col in cols:
                field_no = 0
                values = col.valid_values
                if values is not None and len(values) > 0:
                    line = "  enum " + ''.join(word.title() for word in col.name.split('_')) + "{\n"
                    for i in range(len(values)):
                        v = values[i].replace('-', '_').replace(' ', '_')
                        if v[0:1].isdigit():
                            v = '_' + v
                        line = line + f'    {v} = {field_no};\n'
                        field_no += 1
                    pfile.write(line + '  }\n')

    @staticmethod
    def write_special_imports(udt_name: str):
        if udt_name.startswith('timestamp') or udt_name == 'date':
            return "import \"google/protobuf/timestamp.proto\";\n"
        else:
            return ''

    def write_custom_proto(self, pfile, table: Table):
        comment = "//------------------------ Custom Queries -----------------------------\n"
        pfile.write(comment)
        for qmap in table.mappings.values():
            result_set = qmap.result_set
            if len(result_set) > 0:
                pfile.write('\nmessage ' + ''.join(word.title() for word in qmap.name.split('_')) + '{\n')
                self.write_custom_fields(pfile, result_set)
                pfile.write("}\n")

    def write_custom_fields(self, pfile, result_set: List[BindVar]):
        field_no = 1
        for rset in result_set:
            ftype = postgres_datatypes.sql_to_proto_datatype(rset.data_type)
            if rset.data_type == 'ARRAY':
                field_type = 'repeated'
            else:
                if self.version == 'proto2':
                    field_type = 'optional'
                else:
                    field_type = ''
            pfile.write(f'  ' + field_type + ' ' + ftype + ' ' + rset.name + ' = ' + str(field_no) + ';\n')
            field_no += 1

    def compile_all(self):
        print(f'\n------- Compiling Protobuffers --------\n')
        for schema in self.database.schemas.values():
            for table in schema.tables.values():
                self.compile(table)

    def compile(self, table: Table):
        # protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto
        output_path = self.config.get_config()['output']['path']
        protoc_path = self.config.get_config()['output']['protoc_path']

        src_dir = os.path.sep.join([self.path, table.schema])
        dest_dir = os.path.sep.join([output_path, table.schema])
        fullname = os.path.sep.join([src_dir, table.name + '.proto'])
        print(f'{os.getcwd()} {fullname}')

        cmd = protoc_path + 'protoc -I=' + src_dir + ' --python_out=' + dest_dir + ' ' + fullname
        ret = os.system(cmd)
        if ret is not 0:
            print(f'   Failed to compile proto. Exit code: {ret}')
